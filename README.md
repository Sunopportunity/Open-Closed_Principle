# Open-Closed_Principle
(Game)
### Объяснение:

1. **Шаг 1**: Создаем абстрактный класс `Weapon` с абстрактным методом `attack()`. Это позволяет нам определить интерфейс для всех типов оружия.
2. **Шаг 2**: Реализуем конкретные типы оружия `Sword` и `Bow`, унаследовав их от `Weapon`. Каждый из этих классов реализует метод `attack()` своим уникальным способом.
3. **Шаг 3**: Модифицируем класс `Fighter`, добавив поле `weapon`, которое хранит объект класса `Weapon`, и метод `changeWeapon()`, позволяющий изменить оружие бойца.
4. **Шаг 4**: Реализуем класс `Monster` и простую логику боя, где бойцы сражаются с монстрами, используя выбранное оружие. 

Принцип открытости/закрытости соблюдается, так как мы можем добавлять новые типы оружия (например, `Axe`), не изменяя существующие классы бойцов и механизм боя.


В Python модуль `abc` (abstract base classes) используется для создания абстрактных базовых классов. Абстрактный базовый класс (ABC) — это класс, который не предназначен для создания экземпляров, а служит в качестве шаблона для других классов. Он может содержать один или несколько абстрактных методов, которые должны быть реализованы в подклассе.

Директива `from abc import ABC, abstractmethod` импортирует две вещи из модуля `abc`:

1. `ABC` — это базовый класс для создания абстрактных базовых классов.
2. `abstractmethod` — это декоратор, который используется для обозначения методов как абстрактных.

Пример использования:

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Если попытаться создать экземпляр класса Animal, то будет ошибка
# animal = Animal()  # TypeError: Can't instantiate abstract class Animal with abstract method make_sound

# Но можно создать экземпляры подклассов
dog = Dog()
cat = Cat()
print(dog.make_sound())  # Вывод: Woof!
print(cat.make_sound())  # Вывод: Meow!
```

В этом примере:

- `Animal` — это абстрактный базовый класс, который содержит абстрактный метод `make_sound`.
- `Dog` и `Cat` — это конкретные классы, которые наследуют от `Animal` и реализуют метод `make_sound`.

Попытка создать экземпляр абстрактного класса `Animal` приведет к ошибке, поскольку он содержит не реализованный абстрактный метод.


Создание абстрактного базового класса (ABC) без использования класса `Animal` невозможно, так как сам концепт абстрактного класса предполагает наличие класса, который служит в качестве шаблона для других классов. Абстрактный базовый класс нужен для того, чтобы определить интерфейс (набор методов), который должны реализовать подклассы.

Если вы хотите обойтись без абстрактного класса, то можно просто определить интерфейс в виде документации и возложить ответственность за его соблюдение на разработчиков. Однако это не даст никакой гарантии на уровне языка, что все подклассы будут реализовывать необходимые методы. Вот пример:

```python
# Без использования абстрактного класса

class Dog:
    def make_sound(self):
        return "Woof!"

class Cat:
    def make_sound(self):
        return "Meow!"

# Создаем экземпляры классов
dog = Dog()
cat = Cat()

# Проверяем, что метод make_sound существует и вызываем его
if hasattr(dog, 'make_sound') and callable(getattr(dog, 'make_sound')):
    print(dog.make_sound())  # Вывод: Woof!

if hasattr(cat, 'make_sound') and callable(getattr(cat, 'make_sound')):
    print(cat.make_sound())  # Вывод: Meow!
```

В этом примере метод `make_sound` не является абстрактным, и нет никакой гарантии, что каждый новый класс будет его реализовывать. Вы можете проверять наличие метода во время выполнения с помощью функций `hasattr` и `callable`, но это не так надежно, как использование абстрактного класса.

Использование абстрактных классов и методов в Python дает вам возможность явно определять интерфейсы и обеспечивать, что все подклассы реализуют необходимые методы. Это улучшает читаемость и поддерживаемость кода, а также помогает избегать ошибок на этапе разработки.